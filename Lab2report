					Lab2实验报告
Part1
	Thinking2.1
首先，用{//.....}这样的结构是编译不过去的。在定义一些复杂的宏的时候，往往需要这样的宏是一个整体，
这样就可以避免在实现宏的时候由于直接引用出现一些错误，比如#define fun A;B;，A，B分别是两条语句，
当函数中执行if（条件） fun; 时，直接引用的话就会是if (条件){A;}  B;  即A,B两条语句分别在条件块内外，
而用do{//..}while(0)这样的结构就可以避免这样的事情发生。这样就可以实现一些复杂的宏的定义。
	Thinking2.2
		对于起始地址0xc0000000，这一地址相当于第0xc0000000>>12个页表项，同时也是第一个页目录项，每一个
		页表项大小为4个字节，则第一个页目录项相对于0xc0000000的偏移为（0xc0000000>>12）*4=0x00300000，
		因此页目录的起始地址是0xc0000000+0x00300000 = 0xc0300000。
	Thinking2.3
		index寄存器在之前存着小于0的数，在执行tlbp这条指令时，如果匹配到了快表中的某一项，则把快表的此
		项下标存在index寄存器里，如果未找到不作处理，当执行到mfc0 k0,CP0_INDEX时，k0的值被赋为一个负值，
		因此在bltz,k0,NOFOUND这条指令时，由于k0<0，则会跳转到NOFOUND。

Part2
	 

Part3
    第二次实验相较于第一次实验来说难度更大了，这次接触到了操作系统的内存管理。 因此本次实验花费的时间更长基本用完了3周时间。
    这次实验中用到了好多计组学到的东西，还有数据结构学到的东西，让我深深体会到，计算机的各种科目都是想通的。
    这次实验中，填写函数时候需要各种虚拟地址和物理地址的转换，不光要了解mips的内存布局，还要了解虚拟地址和物理地址的映射方式。
什么时候该用到虚拟地址，什么时候需要用到物理地址这都是必须要应该清楚的。要不然在填写函数的时候很容易就会出各种各样的错误。我
做的时候就是这样，有时候该用到虚拟地址的时候没有转换，该用到物理地址却用的虚拟地址，最后导致很多错误，边调试边请教才最终解决。
所以，细心很重要。
Part4
	每填完一个函数都心里没有底，不知道对不对。只有把所有的函数都填完才能对着正确结果验证，就算错了也不好调试，
所以能不能在以后的指导书中贴出每一个函数填完后应该有怎样的输出，这样更容易调试。
